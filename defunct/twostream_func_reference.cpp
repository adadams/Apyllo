vector<double> Planet::getFlux(vector<double> wavens, string table, vector<vector<double > > taulayer, vector<vector<double > > w0, vector<vector<double > > asym){  // 8 Gauss points  int nGauss = 8;  vector<double> gaussPoints(nGauss,0);  vector<double> gaussWeights(nGauss,0);  // Cosines of angles to calculate the streams  gaussPoints[0] = 0.0446339553;  gaussPoints[1] = 0.1443662570;  gaussPoints[2] = 0.2868247571;  gaussPoints[3] = 0.4548133152;  gaussPoints[4] = 0.6280678354;  gaussPoints[5] = 0.7856915206;  gaussPoints[6] = 0.9086763921;  gaussPoints[7] = 0.9822200849;  // Weights for the streams  gaussWeights[0] = 0.0032951914;  gaussWeights[1] = 0.0178429027;  gaussWeights[2] = 0.0454393195;  gaussWeights[3] = 0.0791995995;  gaussWeights[4] = 0.1060473494;  gaussWeights[5] = 0.1125057995;  gaussWeights[6] = 0.0911190236;  gaussWeights[7] = 0.0445508044;  // Surface reflectivity should be zero for emission.  // (It is used in the tridiagonal matrix in the bottom layer.)  double ubari = 0.5;    // This is mu_1 in Toon et al.  double rsf = 0.;       // "surface" reflectivity, can set to zero  int nl2 = 2*nlayer;    // Needed for the DSOLVER subroutine.  int nlevelshort = nlevel;  int nlayershort = nlayer;  double tbase = getT(hmin);  double tbfrac = 1.;  for(int i=0; i<nlayer; i++){    if(hprof[i]<hmin){      tbfrac = (hprof[i-1]-hmin)/(hprof[i-1]-hprof[i]);      nlevelshort = i;      nlayershort = i-1;      nl2 = 2*nlayershort;      break;    }  }      vector<double> fdown(nlevelshort,0);  vector<double> fup(nlevelshort,0);  vector<double> alpha(nlayershort,0);  vector<double> lamda(nlayershort,0);  vector<double> gama(nlayershort,0);  if(table == "hires"){    blayer = vector<vector<double> >(wavens.size(),vector<double>(nlayer,0));  }  vector<double> b0(nlayershort,0);  vector<double> b1(nlayershort,0);  vector<double> bdiff(nlayershort,0);  vector<double> cp(nlayershort,0);  vector<double> cm(nlayershort,0);  vector<double> cpm1(nlayershort,0);  vector<double> cmm1(nlayershort,0);  vector<double> e1(nlayershort,0);  vector<double> e2(nlayershort,0);  vector<double> e3(nlayershort,0);  vector<double> e4(nlayershort,0);  vector<double> gg(nlayershort,0);  vector<double> hh(nlayershort,0);  vector<double> xj(nlayershort,0);  vector<double> xk(nlayershort,0);  vector<double> af(nl2,0);  vector<double> bf(nl2,0);  vector<double> cf(nl2,0);  vector<double> df(nl2,0);  vector<double> as(nl2,0);  vector<double> ds(nl2,0);  vector<double> xki(nl2,0);  vector<double> xk1(nlayershort,0);  vector<double> xk2(nlayershort,0);  vector<double> alpha1(nlayershort,0);  vector<double> alpha2(nlayershort,0);  vector<double> sigma1(nlayershort,0);  vector<double> sigma2(nlayershort,0);  vector<double> em1(nlevelshort,0);  vector<double> em2(nlevelshort,0);  vector<double> em3(nlevelshort,0);  vector<double> epp(nlevelshort,0);  vector<double> fpt(nlevelshort,0);  vector<double> fmt(nlevelshort,0);  vector<double> totalflux(wavens.size(),0);  // cosbar is layer asymmetry parameter with layer 0 on top  // zero for most circumstances; may be nonzero for high cloud opacity  vector<double> cosbar(nlayershort,0);  for(int i=0; i<wavens.size(); i++){    double wavelength = wavens[i]/1.e4;    double btop;    double bottom;    double bsurf;    if(table == "hires"){      // computes blackbody emission by layer from top to bottom      for(int j=0; j<nlayershort; j++){	// These variables are used to compute the quadrature using the	// hemispherical mean approximation found in Toon et al. (1989).	// lamda is the lambda in their paper, gama is the capital-Gamma, and term is 1/(gamma_1 + gamma_2)	// Verified algebraically.		cosbar[j] = asym[i][j];	alpha[j] = sqrt( (1.-w0[i][j])/(1.-w0[i][j]*cosbar[j]) );	lamda[j] = alpha[j]*(1.-w0[i][j]*cosbar[j])/ubari;	gama[j] = (1.-alpha[j])/(1.+alpha[j]);	double term = 0.5/(1.-w0[i][j]*cosbar[j]);      	b0[j] = blackbodyL(tprof[j],wavelength);	b1[j] = blackbodyL(tprof[j+1],wavelength);	bdiff[j] = (b1[j]-b0[j])/taulayer[i][j];      	if(taulayer[i][j]<1.e-6){	  b0[j] = 0.5*(blackbodyL(tprof[j],wavelength)+blackbodyL(tprof[j+1],wavelength));	  bdiff[j] = 0.;	}	// ada: filling a 2-D array for blackbody intensities for use in \	calculating the contribution functions.                                 	blayer[i][j] = b0[j];	// These are the blackbody fluxes corrected for the quadrature.	// cp and cm are C^+ and C^- in Toon et al., evaluated at the bottom of the atmosphere.	// Except Toon et al. add a factor of 2*pi*mu_1. This appears to be added back in for gg and hh.	// cpm1 and cmm1 are C^+ and C^-, evaluated at the top of the atmosphere.	cp[j] = b0[j] + bdiff[j]*taulayer[i][j] + bdiff[j]*term; // = b1 + bdiff*term	cm[j] = b0[j] + bdiff[j]*taulayer[i][j] - bdiff[j]*term; // = b1 - bdiff*term	cpm1[j] = b0[j] + bdiff[j]*term;	cmm1[j] = b0[j] - bdiff[j]*term;      } // End of blackbody loop.      // These are the attenuation coefficients exp(-taulayer) corrected for the quadrature.      // Set a maximum lambda*tau = 35 to prevent overflow.      for(int j=0; j<nlayershort; j++){	double ep = exp( min(lamda[j]*taulayer[i][j], 35.) );	e1[j] = ep + gama[j]/ep;	e2[j] = ep - gama[j]/ep;	e3[j] = gama[j]*ep + 1./ep;	e4[j] = gama[j]*ep - 1./ep;      }      double tautop = taulayer[i][0];      btop = (1. - exp(-tautop/ubari))*blackbodyL(tprof[0],wavelength);      //double bsurf = b0[nlayershort-1];      //if(hprof[nlayershort-1]>=hmin) bsurf = blackbodyL(tprof[nlevelshort-1],wavelength);      //double bsurf = blackbodyL(tprof[nlevelshort-1],wavelength);      //double bottom = bsurf + bdiff[nlayershort-1]*ubari;      bsurf = blackbodyL(tbase,wavelength);      bottom = bsurf + bdiff[nlayershort-1]*ubari/tbfrac; // Equivalent to multiplying taulayer by tbfrac.    } // End of if(table=="hires")        if(table == "lores"){      // computes blackbody emission by layer from top to bottom      for(int j=0; j<nlayershort; j++){		// These variables are used to compute the quadrature using the	// hemispherical mean approximation found in Toon et al. (1989).	// lamda is the lambda in their paper, gama is the capital-Gamma, and term is 1/(gamma_1 + gamma_2)	// Verified algebraically.	cosbar[j] = asymlo[i][j];	alpha[j] = sqrt( (1.-w0lo[i][j])/(1.-w0lo[i][j]*cosbar[j]) );	lamda[j] = alpha[j]*(1.-w0lo[i][j]*cosbar[j])/ubari;	gama[j] = (1.-alpha[j])/(1.+alpha[j]);	double term = 0.5/(1.-w0lo[i][j]*cosbar[j]);		b0[j] = blackbodyL(tprof[j],wavelength);	b1[j] = blackbodyL(tprof[j+1],wavelength);	bdiff[j] = (b1[j]-b0[j])/taulayerlo[i][j];		if(taulayerlo[i][j]<1.e-6){	  b0[j] = 0.5*(blackbodyL(tprof[j],wavelength)+blackbodyL(tprof[j+1],wavelength));	  bdiff[j] = 0.;	}		// These are the blackbody fluxes corrected for the quadrature.	// cp and cm are C^+ and C^- in Toon et al., evaluated at the bottom of the atmosphere.	// Except Toon et al. add a factor of 2*pi*mu_1. This appears to be added back in for gg and hh.	// cpm1 and cmm1 are C^+ and C^-, evaluated at the top of the atmosphere.	cp[j] = b0[j] + bdiff[j]*taulayerlo[i][j] + bdiff[j]*term; // = b1 + bdiff*term	cm[j] = b0[j] + bdiff[j]*taulayerlo[i][j] - bdiff[j]*term; // = b1 - bdiff*term	cpm1[j] = b0[j] + bdiff[j]*term;	cmm1[j] = b0[j] - bdiff[j]*term;      } // End of blackbody loop.            // These are the attenuation coefficients exp(-taulayer) corrected for the quadrature.      // Set a maximum lambda*tau = 35 to prevent overflow.      for(int j=0; j<nlayershort; j++){	double ep = exp( min(lamda[j]*taulayerlo[i][j], 35.) );	e1[j] = ep + gama[j]/ep;	e2[j] = ep - gama[j]/ep;	e3[j] = gama[j]*ep + 1./ep;	e4[j] = gama[j]*ep - 1./ep;      }            double tautop = taulayerlo[i][0];      btop = (1. - exp(-tautop/ubari))*blackbodyL(tprof[0],wavelength);      //double bsurf = b0[nlayershort-1];      //if(hprof[nlayershort-1]>=hmin) bsurf = blackbodyL(tprof[nlevelshort-1],wavelength);      //double bsurf = blackbodyL(tprof[nlevelshort-1],wavelength);      //double bottom = bsurf + bdiff[nlayershort-1]*ubari;      bsurf = blackbodyL(tbase,wavelength);      bottom = bsurf + bdiff[nlayershort-1]*ubari/tbfrac;    } // End of if(table=="lores")          // DSolver subroutine to compute xk1 and xk2.    // Computes a,b,c,d coefficients first, top to bottom    // Then as and ds, *bottom to top*    // Then xk coefficients, top to bottom    // af, bd, cd, and df appear to be A_l, B_l, D_l, and E_l in Toon et al.    // xk1 and xk2 appear to be Y_1n and Y_2n in Toon et al.    // However, these do not match their formulae.    af[0] = 0.;    bf[0] = gama[0] + 1.;    cf[0] = gama[0] - 1.;    df[0] = btop - cmm1[0];        int nn=0;    int lm1 = nl2-1;        // even indices -- NOTE: even and odd have been switched from the    // Fortran code and Toon et al. due to fencepost effects.    for(int ii=2; ii<lm1; ii+=2){      af[ii] = 2.*(1.-gama[nn]*gama[nn]);      bf[ii] = (e1[nn]-e3[nn])*(1.+gama[nn+1]);      cf[ii] = (e1[nn]+e3[nn])*(gama[nn+1]-1.);      df[ii] = e3[nn]*(cpm1[nn+1]-cp[nn]) + e1[nn]*(cm[nn]-cmm1[nn+1]);      nn++;    }        nn=0;    int lm2 = nl2-2;    // odd indices    for(int ii=1; ii<lm2; ii+=2){      af[ii] = (e1[nn]+e3[nn])*(gama[nn+1]-1.);      bf[ii] = (e2[nn]+e4[nn])*(gama[nn+1]-1.);      cf[ii] = 2.*(1.-gama[nn+1]*gama[nn+1]);      df[ii] = (gama[nn+1]-1.)*(cpm1[nn+1]-cp[nn]) + (1.-gama[nn+1])*(cm[nn]-cmm1[nn+1]);      nn++;    }    af[nl2-1] = e1[nlayershort-1] - rsf*e3[nlayershort-1];    bf[nl2-1] = e2[nlayershort-1] - rsf*e4[nlayershort-1];    cf[nl2-1] = 0.;    df[nl2-1] = bottom - cp[nlayershort-1] + rsf*cm[nlayershort-1]; // original says bsurf, but was called with bottom        // DTRIDGL subroutine to compute the necessary xki array    // This matches the algorithm in Toon et al.    as[nl2-1] = af[nl2-1]/bf[nl2-1];    ds[nl2-1] = df[nl2-1]/bf[nl2-1];    for(int ii=2; ii<nl2; ii++){      double xx = 1./(bf[nl2-ii] - cf[nl2-ii]*as[nl2-ii+1]);      as[nl2-ii] = af[nl2-ii]*xx;      ds[nl2-ii] = (df[nl2-ii] - cf[nl2-ii]*ds[nl2-ii+1])*xx;    }    xki[0] = ds[0];    for(int ii=1; ii<nl2; ii++){      xki[ii] = ds[ii] - as[ii]*xki[ii-1];    }    // End of DTRIDGL subroutine        for(int n3=0; n3<nlayershort; n3++){      xk1[n3] = xki[2*n3] + xki[2*n3+1];      xk2[n3] = xki[2*n3] - xki[2*n3+1];      if(xk2[n3]!=0. && fabs(xk2[n3]/xk[2*n3] < 1.e-30)) xk2[n3] = 0.;    }    // End of DSolver subroutine.    // These are the variables that are used to compute the flux.    // They are all functions of the e-coefficient and blackbody fluxes via the matrix solver.    if(table == "hires"){      for(int ng=0; ng<nGauss; ng++){	double ugauss = gaussPoints[ng];	for(int j=0; j<nlayershort; j++){	  if(w0[i][j]>=0.01){	    double alphax = sqrt( (1.-w0[i][j])/(1.-w0[i][j]*cosbar[j]) );	    gg[j] = 2.*pi*w0[i][j]*xk1[j]*(1.+cosbar[j]*alphax)/(1.+alphax);	    hh[j] = 2.*pi*w0[i][j]*xk2[j]*(1.-cosbar[j]*alphax)/(1.+alphax);	    xj[j] = 2.*pi*w0[i][j]*xk1[j]*(1.-cosbar[j]*alphax)/(1.+alphax);	    xk[j] = 2.*pi*w0[i][j]*xk2[j]*(1.+cosbar[j]*alphax)/(1.+alphax);	    alpha1[j] = 2.*pi*(b0[j] + bdiff[j]*(ubari*w0[i][j]*cosbar[j]/(1.-w0[i][j]*cosbar[j])));	    alpha2[j] = 2.*pi*bdiff[j];	    sigma1[j] = 2.*pi*(b0[j] - bdiff[j]*(ubari*w0[i][j]*cosbar[j]/(1.-w0[i][j]*cosbar[j])));	    sigma2[j] = alpha2[j];	  }	  else{	    gg[j] = 0.;	    hh[j] = 0.;	    xj[j] = 0.;	    xk[j] = 0.;	    alpha1[j] = 2.*pi*b0[j];	    alpha2[j] = 2.*pi*bdiff[j];	    sigma1[j] = alpha1[j];	    sigma2[j] = alpha2[j];	  }	}      	// fpt is the outward flux, computed by adding up the quadrature terms.	// fmt is the inward flux.	fpt[nlevelshort-1] = 2.*pi*(bsurf + bdiff[nlayershort-1]*ugauss); // which is the same as bottom.	//fmt[0] = 2.*pi*(1.-exp(-tautop/ugauss))*blackbodyL(tprof[0],wavelength);		for(int j=0; j<nlayershort; j++){	  em1[j] = exp(-lamda[j]*taulayer[i][j]);	  em2[j] = exp(-taulayer[i][j]/ugauss);	  em3[j] = em1[j]*em2[j];	  epp[j] = exp( min(lamda[j]*taulayer[i][j], 35.) );	  /*	    fmt[j+1] = fmt[j]*em2[j];	    fmt[j+1] += xj[j]/(lamda[j]*ugauss+1.)*(epp[j]-em2[j]);	    fmt[j+1] += xk[j]/(lamda[j]*ugauss-1.)*(em2[j]-em1[j]);	    fmt[j+1] += sigma1[j]*(1.-em2[j]);	    fmt[j+1] += sigma2[j]*(ugauss*em2[j]+taulayer[i][j]-ugauss);	  */	}		for(int j=nlayershort-1; j>=0; j--){	  fpt[j] = fpt[j+1]*em2[j];	  fpt[j] += gg[j]/(lamda[j]*ugauss-1.)*(epp[j]*em2[j]-1.);	  fpt[j] += hh[j]/(lamda[j]*ugauss+1.)*(1.-em3[j]);	  fpt[j] += alpha1[j]*(1.-em2[j]);	  fpt[j] += alpha2[j]*(ugauss - (taulayer[i][j]+ugauss)*em2[j]);	}		totalflux[i] += gaussWeights[ng]*fpt[0];      } // end of ng for loop    } // end of if(table=="hires")    if(table == "lores"){      for(int ng=0; ng<nGauss; ng++){	double ugauss = gaussPoints[ng];		for(int j=0; j<nlayershort; j++){	  if(w0lo[i][j]>=0.01){	    double alphax = sqrt( (1.-w0lo[i][j])/(1.-w0lo[i][j]*cosbar[j]) );	    gg[j] = 2.*pi*w0lo[i][j]*xk1[j]*(1.+cosbar[j]*alphax)/(1.+alphax);	    hh[j] = 2.*pi*w0lo[i][j]*xk2[j]*(1.-cosbar[j]*alphax)/(1.+alphax);	    xj[j] = 2.*pi*w0lo[i][j]*xk1[j]*(1.-cosbar[j]*alphax)/(1.+alphax);	    xk[j] = 2.*pi*w0lo[i][j]*xk2[j]*(1.+cosbar[j]*alphax)/(1.+alphax);	    alpha1[j] = 2.*pi*(b0[j] + bdiff[j]*(ubari*w0lo[i][j]*cosbar[j]/(1.-w0lo[i][j]*cosbar[j])));	    alpha2[j] = 2.*pi*bdiff[j];	    sigma1[j] = 2.*pi*(b0[j] - bdiff[j]*(ubari*w0lo[i][j]*cosbar[j]/(1.-w0lo[i][j]*cosbar[j])));	    sigma2[j] = alpha2[j];	  }	  else{	    gg[j] = 0.;	    hh[j] = 0.;	    xj[j] = 0.;	    xk[j] = 0.;	    alpha1[j] = 2.*pi*b0[j];	    alpha2[j] = 2.*pi*bdiff[j];	    sigma1[j] = alpha1[j];	    sigma2[j] = alpha2[j];	  }	}      	// fpt is the outward flux, computed by adding up the quadrature terms.	// fmt is the inward flux.	fpt[nlevelshort-1] = 2.*pi*(bsurf + bdiff[nlayershort-1]*ugauss); // which is the same as bottom.	//fmt[0] = 2.*pi*(1.-exp(-tautop/ugauss))*blackbodyL(tprof[0],wavelength);		for(int j=0; j<nlayershort; j++){	  em1[j] = exp(-lamda[j]*taulayerlo[i][j]);	  em2[j] = exp(-taulayerlo[i][j]/ugauss);	  em3[j] = em1[j]*em2[j];	  epp[j] = exp( min(lamda[j]*taulayerlo[i][j], 35.) );	  /*	    fmt[j+1] = fmt[j]*em2[j];	    fmt[j+1] += xj[j]/(lamda[j]*ugauss+1.)*(epp[j]-em2[j]);	    fmt[j+1] += xk[j]/(lamda[j]*ugauss-1.)*(em2[j]-em1[j]);	    fmt[j+1] += sigma1[j]*(1.-em2[j]);	    fmt[j+1] += sigma2[j]*(ugauss*em2[j]+taulayerlo[i][j]-ugauss);	  */	}		for(int j=nlayershort-1; j>=0; j--){	  fpt[j] = fpt[j+1]*em2[j];	  fpt[j] += gg[j]/(lamda[j]*ugauss-1.)*(epp[j]*em2[j]-1.);	  fpt[j] += hh[j]/(lamda[j]*ugauss+1.)*(1.-em3[j]);	  fpt[j] += alpha1[j]*(1.-em2[j]);	  fpt[j] += alpha2[j]*(ugauss - (taulayerlo[i][j]+ugauss)*em2[j]);	}		totalflux[i] += gaussWeights[ng]*fpt[0];      } // end of ng for loop    } // end of if(table=="lores")  } // end of i for loop (wavens)    return totalflux;}// end getFlux